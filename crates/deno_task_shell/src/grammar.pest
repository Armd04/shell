// grammar.pest

// Whitespace and comments
WHITESPACE = _{ " " | "\t" | ("\\" ~ WHITESPACE* ~ NEWLINE) }
COMMENT = _{ "#" ~ (!NEWLINE ~ ANY)* }

// Basic tokens
WORD_WITH_EQUAL = ${ "="? ~ (!(WHITESPACE | OPERATOR | NEWLINE) ~ ANY)+ }
WORD = ${ (!(WHITESPACE | OPERATOR | NEWLINE) ~ ANY)+ }
QUOTED_WORD = ${ DOUBLE_QUOTED | SINGLE_QUOTED }
DOUBLE_QUOTED = @{ "\"" ~ (!"\"" ~ ANY)* ~ "\"" }
SINGLE_QUOTED = @{ "'" ~ (!"'" ~ ANY)* ~ "'" }
NAME = ${ (ASCII_ALPHA | "_") ~ (ASCII_ALPHANUMERIC | "_")* }
ASSIGNMENT_WORD = ${ NAME ~ "=" ~ WORD }
IO_NUMBER = @{ ASCII_DIGIT+ }

// Special tokens
AND_IF = { "&&" }
OR_IF = { "||" }
DSEMI = { ";;" }
LESS = { "<" }
GREAT = { ">" }
DLESS = { "<<" }
DGREAT = { ">>" }
LESSAND = { "<&" }
GREATAND = { ">&" }
LESSGREAT = { "<>" }
DLESSDASH = { "<<-" }
CLOBBER = { ">|" }
AMPERSAND = { "&" }

// Operators
OPERATOR = _{
    AND_IF | OR_IF | DSEMI | DLESS | DGREAT | LESSAND | GREATAND | LESSGREAT | DLESSDASH | CLOBBER |
    "(" | ")" | "{" | "}" | ";" | "&" | "|" | "<" | ">" | "!"
}

// Reserved words
If = { "if" }
Then = { "then" }
Else = { "else" }
Elif = { "elif" }
Fi = { "fi" }
Do = { "do" }
Done = { "done" }
Case = { "case" }
Esac = { "esac" }
While = { "while" }
Until = { "until" }
For = { "for" }
Lbrace = { "{" }
Rbrace = { "}" }
Bang = { "!" }
In = { "in" }
Stdout = { "|" }
StdoutStderr = { "|&" }

RESERVED_WORD = _{
    If | Then | Else | Elif | Fi | Do | Done |
    Case | Esac | While | Until | For |
    Lbrace | Rbrace | Bang | In |
    Stdout | StdoutStderr
}

// Main grammar rules
complete_command = _{ (list ~ separator)* ~ list ~ separator? }
list = { and_or ~ (separator_op ~ and_or)* ~ separator_op? }
and_or = { pipeline ~ ((AND_IF | OR_IF) ~ linebreak ~ pipeline)* }
pipeline = { Bang? ~ pipe_sequence }
pipe_sequence = { command ~ (Stdout | StdoutStderr ~ linebreak ~ pipe_sequence)* }

command = {
    simple_command |
    compound_command ~ redirect_list? |
    function_definition
}

compound_command = {
    brace_group |
    subshell |
    for_clause |
    case_clause |
    if_clause |
    while_clause |
    until_clause
}

subshell = { "(" ~ compound_list ~ ")" }
compound_list = { (newline_list? ~ term ~ separator?)+ }
term = { and_or ~ (separator ~ and_or)* }

for_clause = {
    For ~ name ~ linebreak ~
    (linebreak ~ In ~ wordlist? ~ sequential_sep)? ~
    linebreak ~ do_group
}

case_clause = {
    Case ~ WORD ~ linebreak ~
    linebreak ~ In ~ linebreak ~
    (case_list | case_list_ns)? ~
    Esac
}

case_list = {
    case_item+
}

case_list_ns = {
    case_item_ns+
}

case_item = {
    "("? ~ pattern ~ ")" ~ (compound_list | linebreak) ~ DSEMI ~ linebreak
}

case_item_ns = {
    "("? ~ pattern ~ ")" ~ compound_list? ~ linebreak
}

pattern = {
    (Esac | WORD) ~ ("|" ~ WORD)*
}

if_clause = {
    If ~ compound_list ~
    Then ~ compound_list ~
    else_part? ~
    Fi
}

else_part = {
    Elif ~ compound_list ~ Then ~ else_part |
    Else ~ compound_list
}

while_clause = { While ~ compound_list ~ do_group }
until_clause = { Until ~ compound_list ~ do_group }

function_definition = { fname ~ "(" ~ ")" ~ linebreak ~ function_body }
function_body = { compound_command ~ redirect_list? }

fname = @{ RESERVED_WORD | NAME | WORD_WITH_EQUAL | ASSIGNMENT_WORD }
name = @{ NAME }

brace_group = { Lbrace ~ compound_list ~ Rbrace }
do_group = { Do ~ compound_list ~ Done }

simple_command = {
    cmd_prefix ~ cmd_word ~ cmd_suffix? |
    cmd_prefix |
    cmd_name ~ cmd_suffix?
}

cmd_prefix = { (io_redirect | ASSIGNMENT_WORD)+ }
cmd_suffix = { (io_redirect | QUOTED_WORD | WORD)+ }
cmd_name = @{ (RESERVED_WORD | WORD) }
cmd_word = @{ WORD_WITH_EQUAL | ASSIGNMENT_WORD }

redirect_list = { io_redirect+ }
io_redirect = { (IO_NUMBER | AMPERSAND)? ~ (io_file | io_here) }
io_file = { 
    LESS ~ filename | 
    GREAT ~ filename | 
    DGREAT ~ filename | 
    LESSAND ~ filename | 
    GREATAND ~ filename | 
    LESSGREAT ~ filename | 
    CLOBBER ~ filename
}
filename = @{ WORD }
io_here = { (DLESS | DLESSDASH) ~ here_end }
here_end = @{ ("\"" ~ WORD ~ "\"") | WORD }

newline_list = { NEWLINE+ }
linebreak = _{ NEWLINE* }
separator_op = { "&" | ";" }
separator = _{ separator_op ~ linebreak | newline_list }
sequential_sep = { ";" ~ linebreak | newline_list }

wordlist = { WORD+ }

// Entry point
FILE = { SOI ~ complete_command ~ EOI }